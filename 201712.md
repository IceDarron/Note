Q:Java重写equals、hashCode和compareTo方法
===
>什么时候需要重写重写equals方法？为什么重写equals方法，一定要重写HashCode方法？

### 何时需要重写equals()
当一个类有自己特有的“逻辑相等”概念（不同于对象身份的概念）。

### 设计equals()
+ 使用instanceof操作符检查“实参是否为正确的类型”。
+ 对于类中的每一个“关键域”，检查实参中的域与当前对象中对应的域值。
+ 对于非float和double类型的原语类型域，使用==比较；
+ 对于对象引用域，递归调用equals方法；
+ 对于float域，使用Float.floatToIntBits(afloat)转换为int，再使用==比较；
+ 对于double域，使用Double.doubleToLongBits(adouble) 转换为int，再使用==比较；
+ 对于数组域，调用Arrays.equals方法。

### 当改写equals()的时候，总是要改写hashCode()
根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode方法，它们仅仅是两个对象。因此，违反了“相等的对象必须具有相等的散列码”。

### 设计hashCode()
+ 把某个非零常数值，例如17，保存在int变量result中；
+ 对于对象中每一个关键域f（指equals方法中考虑的每一个域）：
+ boolean型，计算(f ? 0 : 1);
+ byte,char,short型，计算(int);
+ long型，计算(int) (f ^ (f>>>32));
+ float型，计算Float.floatToIntBits(afloat);
+ double型，计算Double.doubleToLongBits(adouble)得到一个long，再执行long型的计算;
+ 对象引用，递归调用它的hashCode方法;
+ 数组域，对其中每个元素调用它的hashCode方法。
+ 将上面计算得到的散列码保存到int变量c，然后执行 result=37*result+c;
+ 返回result。

### 为什么重写equals方法，一定要重写HashCode方法？
>如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。
使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。
>而对于每一个对象，通过其hashCode()方法可为其生成一个整形值（散列码），该整型值被处理后，将会作为数组下标，存放该对象所对应的Entry（存放该对象及其对应值）。 equals()方法则是在HashMap中插入值或查询时会使用到。当HashMap中插入值或查询值对应的散列码与数组中的散列码相等时，则会通过equals方法比较key值是否相等，所以想以自建对象作为HashMap的key，必须重写该对象继承object的hashCode和equals方法。 
### 本来不就有hashcode()和equals()了么？干嘛要重写，直接用原来的不行么？
>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的，例如，生成了两个“羊”对象，正常理解这两个对象应该是相等的，但如果你不重写 hashcode（）方法的话，比较是不相等的！
>HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素是否相等。
>一般来说，如果你要把一个类的对象放入容器中，那么通常要为其重写equals()方法，让他们比较地址值而不是内容值。特别地，如果要把你的类的对象放入散列中，那么还要重写hashCode()方法；要放到有序容器中，还要重写compareTo()方法。
>equals()相等的两个对象，hashcode()一定相等；
>equals（）不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。（我的理解是由于哈希码在生成的时候产生冲突造成的）。
>反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等

Q:jdk源码中的泛型。
===
>泛型的定义：泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
+ 泛型类
``` Java
class Pair<T> {  
    private T value;  
        public Pair(T value) {  
                this.value=value;  
        }  
        public T getValue() {  
        return value;  
    }  
    public void setValue(T value) {  
        this.value = value;  
    }  
}
```
+ 泛型接口
``` Java
interface Show<T,U>{  
    void show(T t,U u);  
}  
  
class ShowTest implements Show<String,Date>{  
    @Override  
    public void show(String str,Date date) {  
        System.out.println(str);  
        System.out.println(date);  
    }  
} 
```
+ 泛型方法
``` Java
Map<K, V>
```
+ 泛型变量
>类型限定在泛型类、泛型接口和泛型方法中都可以使用，不过要注意下面几点：
1.不管该限定是类还是接口，统一都使用关键字 extends。
2.可以使用&符号给出多个限定。
3.如果限定既有接口也有类，那么类必须只有一个，并且放在首位置。
``` Java
public static <T extends Object&Comparable&Serializable> T get(T t1,T t2)  
```

Q:jdk源码中的异常。
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/java_throwable.png)

Q:mysql设计表
===
+ 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；(只要是关系型数据库都满足1NF)
+ 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
+ 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 没有冗余的数据库设计可以做到。
>但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。

Q:sql及其执行计划优化。
===
+ 何时匹配到索引
>明确第一索引，第二索引的含义。组合索引只能前缀匹配。同样，like 关键字也只能前缀匹配索引，通配符不能放在第一个字符。
+ 何时不走索引
>1.如果mysql 估计索引使用比全表扫描更慢，则不使用索引。例如几乎获取全表数据的范围查询等等。
2.or 分开的条件，OR前的条件列有索引，后面的没有索引，那么涉及的索引都不会用到。
3.条件不是组合索引的第一部分，即不满足前缀左匹配的条件。
4.like 条件以%开始，则不走索引。
5.where 条件后如果是字符串，则一定要用引号括起来，不然自动转换其他类型后，不会走索引。
+ 常用SQL优化
>1.大批量插入数据，使用多值语句插入。insert into test values (1,2),(2,3),(2,4)......
2.优化group by, 默认情况下，mysql 会对所有group by C1,C2,C3 ... 的字段排序，与order by C1,C2,C3 类似，所以在group by 中增加相同列的order by 性能没什么影响。
如果用户想避免排序带来的影响，可以显式指定不排序，后面加上order by NULL。
3.order by 后面的顺序与索引顺序相同，且与where 中使用的条件相同，且是索引，则才会走真正索引。
4.in + 子查询的 SQL 尽量用join 连接来代替。
5.OR 之间的每个条件列都必须用到索引。
6.考虑每次查询时的IO消耗，回表次数。
7.考虑表设计时，数据结构的不同，比如varchar ,char 区别(长度是否固定，空间占用，性能等有本质区别，但在不同的引擎下还有区别)。
8.考虑表设计时每行数据的大小，尽量保持在128K以内，让其在一页内，避免跨页，大数据行。

Q:mysql分库分表设计及优化，读写分离，垂直与水平切分。
===

Q:Redis原理及常见参数调整。
===

Q:Mongodb原理及常见参数调整。
===
