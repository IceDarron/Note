Q:Java重写equals、hashCode和compareTo方法
===
>什么时候需要重写equals方法？为什么重写equals方法，一定要重写HashCode方法？

### 何时需要重写equals()
当一个类有自己特有的“逻辑相等”概念（不同于对象身份的概念）。

### 设计equals()
+ 使用instanceof操作符检查“实参是否为正确的类型”。
+ 对于类中的每一个“关键域”，检查实参中的域与当前对象中对应的域值。
+ 对于非float和double类型的原语类型域，使用==比较；
+ 对于对象引用域，递归调用equals方法；
+ 对于float域，使用Float.floatToIntBits(afloat)转换为int，再使用==比较；
+ 对于double域，使用Double.doubleToLongBits(adouble) 转换为int，再使用==比较；
+ 对于数组域，调用Arrays.equals方法。

### 当改写equals()的时候，总是要改写hashCode()
根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode方法，它们仅仅是两个对象。因此，违反了“相等的对象必须具有相等的散列码”。

### 设计hashCode()
+ 把某个非零常数值，例如17，保存在int变量result中；
+ 对于对象中每一个关键域f（指equals方法中考虑的每一个域）：
+ boolean型，计算(f ? 0 : 1);
+ byte,char,short型，计算(int);
+ long型，计算(int) (f ^ (f>>>32));
+ float型，计算Float.floatToIntBits(afloat);
+ double型，计算Double.doubleToLongBits(adouble)得到一个long，再执行long型的计算;
+ 对象引用，递归调用它的hashCode方法;
+ 数组域，对其中每个元素调用它的hashCode方法。
+ 将上面计算得到的散列码保存到int变量c，然后执行 result=37*result+c;
+ 返回result。

### 为什么重写equals方法，一定要重写HashCode方法？
>如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。
使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。
>而对于每一个对象，通过其hashCode()方法可为其生成一个整形值（散列码），该整型值被处理后，将会作为数组下标，存放该对象所对应的Entry（存放该对象及其对应值）。 equals()方法则是在HashMap中插入值或查询时会使用到。当HashMap中插入值或查询值对应的散列码与数组中的散列码相等时，则会通过equals方法比较key值是否相等，所以想以自建对象作为HashMap的key，必须重写该对象继承object的hashCode和equals方法。 
### 本来不就有hashcode()和equals()了么？干嘛要重写，直接用原来的不行么？
>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的，例如，生成了两个“羊”对象，正常理解这两个对象应该是相等的，但如果你不重写 hashcode（）方法的话，比较是不相等的！
>HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素是否相等。
>一般来说，如果你要把一个类的对象放入容器中，那么通常要为其重写equals()方法，让他们比较地址值而不是内容值。特别地，如果要把你的类的对象放入散列中，那么还要重写hashCode()方法；要放到有序容器中，还要重写compareTo()方法。
>equals()相等的两个对象，hashcode()一定相等；
>equals（）不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。（我的理解是由于哈希码在生成的时候产生冲突造成的）。
>反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等

Q:jdk源码中的泛型。
===
>泛型的定义：泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
+ 泛型类
``` Java
class Pair<T> {  
    private T value;  
        public Pair(T value) {  
                this.value=value;  
        }  
        public T getValue() {  
        return value;  
    }  
    public void setValue(T value) {  
        this.value = value;  
    }  
}
```
+ 泛型接口
``` Java
interface Show<T,U>{  
    void show(T t,U u);  
}  
  
class ShowTest implements Show<String,Date>{  
    @Override  
    public void show(String str,Date date) {  
        System.out.println(str);  
        System.out.println(date);  
    }  
} 
```
+ 泛型方法
``` Java
Map<K, V>
```
+ 泛型变量
>类型限定在泛型类、泛型接口和泛型方法中都可以使用，不过要注意下面几点：
1.不管该限定是类还是接口，统一都使用关键字 extends。
2.可以使用&符号给出多个限定。
3.如果限定既有接口也有类，那么类必须只有一个，并且放在首位置。
``` Java
public static <T extends Object&Comparable&Serializable> T get(T t1,T t2)  
```

Q:Java Throwable
===
> 异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。
Java异常类层次结构图：
![Image text](https://github.com/IceDarron/Note/blob/master/Image/java_throwable.png)
> 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。

### Throwable
> 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。

### Error（错误）
> 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。
。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。

### Exception（异常）
>是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。

+ 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。

### 可查的异常（checked exceptions）&不可查的异常（unchecked exceptions）
#### 可查异常（编译器要求必须处置的异常）
> 正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。

#### 不可查异常(编译器不要求强制处置的异常)
> 包括运行时异常（RuntimeException与其子类）和错误（Error）。
Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。

### 运行时异常&非运行时异常 （编译异常）
#### 运行时异常
> 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。

#### 非运行时异常 （编译异常）
> 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

### 处理异常机制
> 在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。

#### 抛出异常
> 当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。

#### 捕获异常
> 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

> 从方法中抛出的任何异常都必须使用throws子句。捕捉异常通过try-catch语句或者try-catch-finally语句实现。总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。

### try-catch-finally 规则(异常处理语句的语法规则）：
+ 必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。
+ 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。
+ catch 块与相应的异常类的类型相关。
+ 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块
+ 可嵌套 try-catch-finally 结构。
+ 在 try-catch-finally 结构中，可重新抛出异常。
+ 除了下列情况，总将执行 finally 做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。

Q:mysql设计表
===
+ 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；(只要是关系型数据库都满足1NF)
+ 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
+ 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 没有冗余的数据库设计可以做到。
>但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。

Q:sql及其执行计划优化。
===
+ 何时匹配到索引
>明确第一索引，第二索引的含义。组合索引只能前缀匹配。同样，like 关键字也只能前缀匹配索引，通配符不能放在第一个字符。
+ 何时不走索引
>1.如果mysql 估计索引使用比全表扫描更慢，则不使用索引。例如几乎获取全表数据的范围查询等等。
2.or 分开的条件，OR前的条件列有索引，后面的没有索引，那么涉及的索引都不会用到。
3.条件不是组合索引的第一部分，即不满足前缀左匹配的条件。
4.like 条件以%开始，则不走索引。
5.where 条件后如果是字符串，则一定要用引号括起来，不然自动转换其他类型后，不会走索引。
+ 常用SQL优化
>1.大批量插入数据，使用多值语句插入。insert into test values (1,2),(2,3),(2,4)......
2.优化group by, 默认情况下，mysql 会对所有group by C1,C2,C3 ... 的字段排序，与order by C1,C2,C3 类似，所以在group by 中增加相同列的order by 性能没什么影响。
如果用户想避免排序带来的影响，可以显式指定不排序，后面加上order by NULL。
3.order by 后面的顺序与索引顺序相同，且与where 中使用的条件相同，且是索引，则才会走真正索引。
4.in + 子查询的 SQL 尽量用join 连接来代替。
5.OR 之间的每个条件列都必须用到索引。
6.考虑每次查询时的IO消耗，回表次数。
7.考虑表设计时，数据结构的不同，比如varchar ,char 区别(长度是否固定，空间占用，性能等有本质区别，但在不同的引擎下还有区别)。
8.考虑表设计时每行数据的大小，尽量保持在128K以内，让其在一页内，避免跨页，大数据行。


