Q：jvm运行时数据区。
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_data_zone.png)
### 程序计数器
>程序计数器是一块较小的内存空间，每个线程私有，作为当前线程所执行的字节码行号指示器。且如果执行java方法计数器记录，如果执行native方法则计数器值为空。
### java虚拟机栈
>用于描述java方法执行的内存模型，每个方法执行的时候创建一个栈帧，用于存储局部变量，操作数栈，动态链接，方法出口信息等。每一个方法调用至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量可以存储八大基本数据类型及对象引用类型。
### 本地方法栈
>相对于java虚拟机栈，本栈调用的方法为native方法服务。
### java堆
>java虚拟机管理的最大一块内存，所有线程共享，在虚拟机启动的时候创建，只用来存放对象实例。也是GC关注的主要区域。可以分为新生代（Eden，From survivor， To Survivor）和老年代。堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。
### 方法区
>所有线程共享，存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
### 运行时常量池
>这部分内容在来加载后进入方法区。

### 直接内存
>是一种堆外内存，通过一个存储在java堆中的DirecByteBuffer对象作为这个内存的引用进行操作，是由native函数库直接分配的内存，这样可以减少java堆和native堆之间来回复制数据。

Q：对象创建
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_create_object.png)
创建的关键字为new。当虚拟机遇到一个new指令时，会进行一下操作：
1. 检查指令参数是否在常量池中可以定位到一个类的符号引用，并检查所代表的类是否已经被加载、解析和初始化过，如果没有则先执行相应的类加载过程。
2. 为新生对象分配内存。有两种方式：指正碰撞（堆内存绝对规整，通过移动分界指针分配内存），空闲列表（堆内存不规整，维护一个列表，记录内存可用地方）。堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。由于堆是线程共享，所以需要考虑分配内存是，多线程问题。一是通过CAS加失败重试的方法保证分配内存空间的操作的原子性。二是通过对每个线程预先分配堆内存的缓冲区。
3. 对分配完成后的内存空间进行初始化为零值。
4. 虚拟机对对象进行必要设置，主要设置对象内存头的信息。
5. 虚拟机已经产生一个新的对象，最后执行程序编写中的init方法。

Q：对象的内存布局
===
对象在内存中存储的布局分为三块区域：对象头，实例数据，对齐填充。
对象头：分为两部分，第一部分用于存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态等。第二部分是类型指针，即对象指向它的类元数据的指针。
实例数据：对象真正存储的有效信息，即程序中定义的各种类型字段内容。无论父类继承还是子类定义，都记录。
对齐填充：自动内存管理系统要求对象起始地址必须是8字节的倍数。

Q：对象的访问定位
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_obj_visit.png)
栈中存放的引用类型，只规定了一个指向对象的引用，具体如何定位，由虚拟机实现，主要有两种方式：使用句柄，直接指针。（句柄可以理解为指向指针的指针，维护指向对象的指针的变化，对象的句柄本身不变化）

Q：对象是否可回收
===
1. 引用计数算法：通过计数器，引用+1，失效-1，为0时认为不可用。简单高效，但是很难解决对象之间相互循环引用的问题。
2. 可达性分析算法：通过GC Roots对象作为起点，向下搜索形成引用链，如果一个对象到GC Roots之间没有引用链，则认为不可用。GC 
3. Roots包括：虚拟机栈中引用的对象，方法去中类静态属性引用的对象，方法去中常量引用的对象，native方法引用的对象。
4. 可达性分析算法需要至少经历两次标记过程，如果不可达则进行标记并进行筛选（筛选条件为是否有必要执行finalize()方法，当没有重写或已经被虚拟机调用了则认为是没有必要执行），对于需要执行的情况下，则在finalize()方法中可以重新与引用链上的任意对象项链，将会被移除出即将回收的集合，从而避免回收。需要注意的是，任何一个对象的finalize方法只会被系统自动调用一次。不建议这么使用finalize方法，甚至不建议在程序中使用该方法。

Q：引用
===
+ 强引用：例如Object obj = new Object()，强引用存在，则永远不回收。
+ 软引用：通过jdk中SoftReference实现，在发生内存溢出异常之前，进行二次回收。
+ 弱引用：通过jdk中WeakReference实现，只生存到下次垃圾收集发生之前。无论内存是否足够，垃圾收集发生后都回收。
+ 虚引用：通过jdk中PhantomReference实现，无发通过该引用获取一个对象实例，唯一的目的是用来在回收时收到一条系统消息。

Q：垃圾收集算法
===
1. 标记-清除算法
先标记后清除，标记的时候会停顿所有线程。最基础的收集算法，但是效率较低，并且回收后的内存空间不连续，存在大连不连续内存碎片。影响分配大对象。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_gc_mark_sweep.png)
2. 复制算法
内存分为两部分，运行时使用其中一部分，当发起回收时，将存活对象复制到空白内存部分，并清除原先使用的部分。简单高效，空间连续。但是损失内存空间。
经IBM研究新生代98%的对象朝生夕死，所以将new内存分为8:1:1（Eden，From Survivor，To Survivor），每次使用Eden和From Survivor，回收时将存活的对象放到To Survivor上（据说清理后会将To与From交换，保证每次GC后使用的都是Eden和From，回收复制时放置的地方总是To），并清理其他部分。如果Survivor空间不足则需要依赖old部分进行分配担保。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_gc_copying.png)
3. 标记-整理算法
在标记-清除算法基础上，在标记阶段后不直接清除，而是让所有存活对象都向一端移动（整理），然后清除掉整理边界以外的内存。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_gc_mark_compact.png)
4. 分代收集算法
是一种针对将内存分为不同区域，各个区域使用自己合适的收集算法，通常java堆分为new和old（新生代，老年代），new使用复制算法，old使用标记-xx算法。


Q：HotSpot的算法实现
===
1. 枚举根节点
为可达性分析做准备，必须停顿所有java执行线程，通过一组成为OopMap的数据结构得知哪些地方存放着对象引用。
2. 安全点
对于达到安全点的地方记录指令并存入OopMap中。通常有抢先式中断（基本已弃用）和主动式中断。抢先式中断：GC发生，首先发所有线程中断，发现中断的地方不在安全点则回复线程并跑到安全点。主动式中断，设置一个标志位，当需要中断时修改标志位，并让线程主动轮询标志位，在中断。标志位本身与安全点重合。
3. 安全区域
对于处于sleep和block的线程无法响应jvm中断请求，这些线程会进入安全区域，安全区域线程可以GC。当离开安全区域时，需要检查系统是否完成枚举根节点或GC，如果完成则线程继续执行，否则等待。


Q：垃圾收集器
===
HotSpot垃圾收集器关系图：
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_generation.png)
#### Serial：
>最基本，发展历史最悠久的单线程收集器，运行时必须暂停其他所有的工作线程，直到收集结束。但是简单高效，由于单线程没有线程交互开销，从而获得最高的单线程收集效率。
#### ParNew：
>与Serial基本相同，只是拥有了多线程收集能力。
#### Parallel Scavenge：
>设计出发点与其他收集器较为不同，它的目标是达到一个可控制的吞吐量，即CPU用于运行用户代码的时间与CPU总消耗时间的比值（其实就是从整体的视角来看，降低收集的停顿总时间，从而提高CPU使用率）。除此之外，它还拥有GC自适应的调节策略，动态调整参数以提供最适合的停顿时间或吞吐量。从多线程和回收算法来看与ParNew并无不同。
#### Serial Old：
>Serial的老年代版本，同样是单线程，用于搭配Paralle Scavenge和为CMS提供后备方案。但是它使用的标记-整理算法。
#### Parallel Old：
>Parallel Scavenge的老年代版本，多线程。主要是为了配合Parallel Scavenge，替代Serial Old。从而提供一个吞吐量优先的收集器组合。但是它使用的标记-整理算法。
#### CMS：
>是一种获取最短停顿时间的收集器，多用于互联网或者BS系统的服务端，重视响应速度，也是第一个并发收集器。基于标记-清除算法，分为四个阶段（初始标记，并发标记，重新标记，并发清除）。缺点在于对CPU资源敏感，无法处理浮动垃圾（即在并发清理阶段用户线程运行时出现的垃圾，并且存在预留空间不足而回收失败需要启用Serial Old回收垃圾），标记-清除算法的通病产生大量不连续空间碎片。
#### G1：
+ 并行与并发：多线程可以充分利用CPU性能，且GC时java程序仍旧可运行。
+ 分代收集：可以不需要配合其它收集器，自身可以采用不同的方式处理各个阶段的对象。
+ 空间整合：不会产生内存碎片。
+ 可预测的停顿：实时java（RTSJ）的一个特征，可以在指定M毫秒时间段内回收时间不超过N毫秒。
>java内存布局与其他收集器有很大区别，将整个java堆划分为多个大小相同的独立区域（region），新生代和老年代已经不是物理隔离，都是一部分可以不连续的region的集合。G1跟踪每个region的回收价值，在后台维护一个优先列表，回收价值最大的region。
>存在Remembered Set维护操作，用来保证回收时做可达性分析判断时不需要对整个java堆进行扫描。除去该操作G1共分为以下几步：初始标记，并发标记，最终标记，筛选回收。
#### GC日志：
>每个收集器的日志格式不一样，但虚拟机设计时尽量将各个收集器的日志维持了一定的共性。日志格式大致为：
+ 100.661 : [Full GC [Tenured : 0K->210(10240K), 0.149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21245K)], 0.0150007 secs] [Times:user=0.01 sys=0.00, real=0.02 secs]
+ 时间：[停顿类型 [GC发生区域 ： GC前内存已使用容量->GC后内存已使用容量(内存总容量)] GC前java堆已用容量->GC后java堆已用容量(堆总容量), 内存区域GC所占用时间][具体时间：用户态消耗cpu时间，内核态消耗cpu时间，操作从开始到结束所经过的墙钟时间] 
#### 其他部分
+ 停顿时间越短就越适合需要与用户交互的程序。而高吞吐量则高效利用CPU适合多后台运算少交互的任务。
+ 自动内存管理主要为对象分配内存和回收分配给对象的内存。对象的内存分配，大方向来看就是在堆上分配，且主要就是在Eden。这里介绍下：新生代GC(Minor GC)频分但回收速度快。老年代GC(Major GC/Full GC)速度较于Minor GC慢10倍以上。
+ 大对象：需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串及数组。通常直接进入老年代。
+ 通过对象年龄计数器可以判断长期存活的对象是否将进入老年代，通常在Eden生成的对象在第一次Minor GC后仍然存活并被Survivor容纳的话将被移动到Survivor中并加一年龄。默认15岁进入老年代。当然也可以动态对象年龄判断，如果在Survior中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代。
+ 空间分配担保：主要由于新生代采用复制算法，在某些情况下可能会空间不足，需要老年代担保才能进行Minor GC 。如果担保后仍然空间不足，那么需要进行一次Full GC 。通过前一次回收晋升老年代对象的容量的平均值作为经验，来判断是否担保成功。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_serial&serial_old.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_parnew&serial_old.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_parallel_scavenge&parallel_old.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_cms.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_g1.png)

  
Q：Java内存模型与线程
===
+ Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不被共享。
+ 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝（事实上，只拷贝在线程中有可能使用到的字段，不会把整个对象拷贝一次）。
+ 线程间变量的传递均需要通过主内存来完成。线程自己的变量均在自己的工作内存中进行，不能直接读写主内存变量，其中volatile修饰的变量，同样拥有工作内存的拷贝，但由于其特殊的操作顺序，可以保证可见性，所以看起来如同直接在主内存中读写访问。
+ 简单的说，主内存主要对应Java堆中的对象实例数据部分，工作内存则对应于虚拟机栈中的部分区域。
+ 内存模型中有八大操作，每个操作都是具有原子性：lock，unlock，read，load，use，assign，store，write。
+ volatile具有可见性和禁止指令重排序优化的特性，但不能保证并发下线程安全。
+ 并发过程中的三大特性：原子性，可见性，有序性。
+ 先行发生原则：判断数据是否存在竞争，线程是否安全的主要依据。
+ 线程的实现：内核线程，用户线程，用户线程及轻量级进程混合。
+ 线程调度：协同式线程调度，抢占式线程调度。
+ 线程状态：新建，运行，无限期等待和限期等待，阻塞，结束。


Q：线程安全与锁优化
===
+ 当多个线程访问同一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
+ 通常有五种级别的线程安全：不可变，绝对线程安全，相对线程安全，线程兼容，线程对立。
+ 线程安全的实现方式：互斥同步（synchronized和reentrantlock），非阻塞同步（CAS等），无同步方案（可重用代码和线程本地存储，本身无共享数据）
+ 锁优化：为了线程之间更高效的共享数据，解决竞争问题。
+ 自旋锁与自适应自旋：由于挂起线程和恢复线程需要在内核态完成，很浪费性能，并且共享数据的锁定通常持续时间很短，所以通过减少不必要的挂起和恢复，通过让线程执行一个忙循环（自旋），使线程不放弃cpu占用时间，让后续线程等待锁。自旋等待不等于代替阻塞。自旋等待的效果取决于锁占用的时间是否很短，时间短效果好。自适应自旋是自旋的升级版，通过前一个同一个锁上的自旋时间及锁拥有者的状态自动调整自旋时间。
+ 锁消除：虚拟机即时编译器运行时通过逃逸分析的数据支持，检测到不可能存在共享的数据竞争的锁，从而进行消除。例如方法参数为多个string，方法体为参数相加，编译器会自动优化为stringbuffer的append，所以造成了无用的锁。
+ 锁粗化：对一个对象循环进行连续同步操作，可以把加锁同步的范围扩大到整个操作序列的外部。
+ 轻量级锁：在考虑绝大部分锁，在整个同步周期内不存在竞争才能提升性能。通过对象的内存布局，CAS等来操作，如果竞争则开销更大。不能代替重量级锁。
+ 偏向锁：偏向第一个持有该锁的线程，并在该锁没有被其他线程获得的情况下，持有该偏向锁的线程不需要进行同步。如果获取该锁，则偏向模式结束，恢复到未锁定或轻量级锁状态。
+ 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_biased_lock.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_light_lock.png)

|锁      |优点     |缺点      |适用场景|
|--------|---------|---------|---------|
|偏向锁   |加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距|如果线程间存在锁竞争，会带来额外的锁撤销的消耗|适用于只有一个线程访问同步块场景|
|轻量级锁 |竞争的线程不会阻塞，提高了程序的响应速度|如果始终得不到锁竞争的线程使用自旋会消耗CPU|追求响应时间,锁占用时间很短|
|重量级锁 |线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量,锁占用时间较长|



Q:jdk源码（集合）。
=== 
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jdk_collection.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jdk_LinkedHash.png)
+ Iterator
java.util.Iterator接口主要定义了遍历集合对象的方法，通过迭代器模式，创建迭代器来遍历各种集合，每个集合中都有具体的实现。通过迭代器遍历时，在多线程下存在遍历过程中，另一个线程修改集合，这时候通过fast-fail机制可以抛出异常。

+ Collection
>The root interface in the <i>collection hierarchy</i>.  A collection represents a group of objects, known as its <i>elements</i>.  Some
 collections allow duplicate elements and others do not.  Some are ordered and others unordered.  The JDK does not provide any  <i>direct</i> implementations of this interface: it provides implementations of more specific subinterfaces like <tt>Set</tt> and  <tt>List</tt>.  This interface is typically used to pass collections around and manipulate them where maximum generality is desired.

+ List
>具体实现类：ArrayList（数组），Vector（数组），LinkedList（双向链表），Stack（数组）

+ Set
>具体实现类：HashSet（散列表HashMap），TreeSet（二叉树），LinkedHashSet（LinkedHashMap通过继承HashSet并使用它的构造函数实现）
TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet<E>, Cloneable, java.io.Serializable接口。
TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。
TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。
TreeSet 实现了Cloneable接口，意味着它能被克隆。
TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。
TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。

+ Queue
>具体实现类：LinkedBlockingQueue（单向链表实现的阻塞队列），PriorityQueue（数组），ArrayDeque（数组，可以实现队列或栈）
Queue本身是一种先入先出的模型(FIFO)。
Deque是Queue的子接口，是一种增强，代表一个双端队列。同时Deque不仅可以作为双端队列使用，而且可以被当成栈来使用，所以可以使用出栈，入栈的方法。

+ Map
>具体实现类：HashMap（散列表），TreeMap（红黑树数据结构），LinkedHashMap（散列表+双向链表）

+ Collections&Arrays
>提供集合和数组之间的转换，排序，最大值等方法。
