Q：jvm运行时数据区。
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_data_zone.png)
### 程序计数器
>程序计数器是一块较小的内存空间，每个线程私有，作为当前线程所执行的字节码行号指示器。且如果执行java方法计数器记录，如果执行native方法则计数器值为空。
### java虚拟机栈
>用于描述java方法执行的内存模型，每个方法执行的时候创建一个栈帧，用于存储局部变量，操作数栈，动态链接，方法出口信息等。每一个方法调用至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量可以存储八大基本数据类型及对象引用类型。
### 本地方法栈
>相对于java虚拟机栈，本栈调用的方法为native方法服务。
### java堆
>java虚拟机管理的最大一块内存，所有线程共享，在虚拟机启动的时候创建，只用来存放对象实例。也是GC关注的主要区域。可以分为新生代（Eden，From survivor， To Survivor）和老年代。堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。
### 方法区
>所有线程共享，存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
### 运行时常量池
>这部分内容在来加载后进入方法区。

### 直接内存
>是一种堆外内存，通过一个存储在java堆中的DirecByteBuffer对象作为这个内存的引用进行操作，是由native函数库直接分配的内存，这样可以减少java堆和native堆之间来回复制数据。

Q：对象创建
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_create_object.png)
创建的关键字为new。当虚拟机遇到一个new指令时，会进行一下操作：
1. 检查指令参数是否在常量池中可以定位到一个类的符号引用，并检查所代表的类是否已经被加载、解析和初始化过，如果没有则先执行相应的类加载过程。
2. 为新生对象分配内存。有两种方式：指正碰撞（堆内存绝对规整，通过移动分界指针分配内存），空闲列表（堆内存不规整，维护一个列表，记录内存可用地方）。堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。由于堆是线程共享，所以需要考虑分配内存是，多线程问题。一是通过CAS加失败重试的方法保证分配内存空间的操作的原子性。二是通过对每个线程预先分配堆内存的缓冲区。
3. 对分配完成后的内存空间进行初始化为零值。
4. 虚拟机对对象进行必要设置，主要设置对象内存头的信息。
5. 虚拟机已经产生一个新的对象，最后执行程序编写中的init方法。

Q：对象的内存布局
===
对象在内存中存储的布局分为三块区域：对象头，实例数据，对齐填充。
对象头：分为两部分，第一部分用于存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态等。第二部分是类型指针，即对象指向它的类元数据的指针。
实例数据：对象真正存储的有效信息，即程序中定义的各种类型字段内容。无论父类继承还是子类定义，都记录。
对齐填充：自动内存管理系统要求对象起始地址必须是8字节的倍数。

Q：对象的访问定位
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_obj_visit.png)
栈中存放的引用类型，只规定了一个指向对象的引用，具体如何定位，由虚拟机实现，主要有两种方式：使用句柄，直接指针。（句柄可以理解为指向指针的指针，维护指向对象的指针的变化，对象的句柄本身不变化）

Q：对象是否可回收
===
1. 引用计数算法：通过计数器，引用+1，失效-1，为0时认为不可用。简单高效，但是很难解决对象之间相互循环引用的问题。
2. 可达性分析算法：通过GC Roots对象作为起点，向下搜索形成引用链，如果一个对象到GC Roots之间没有引用链，则认为不可用。GC 
2-1. Roots包括：虚拟机栈中引用的对象，方法去中类静态属性引用的对象，方法去中常量引用的对象，native方法引用的对象。

Q：引用
===
+ 强引用：例如Object obj = new Object()，强引用存在，则永远不回收。
+ 软引用：通过jdk中SoftReference实现，在发生内存溢出异常之前，进行二次回收。
+ 弱引用：通过jdk中WeakReference实现，只生存到下次垃圾收集发生之前。无论内存是否足够，垃圾收集发生后都回收。
+ 虚引用：通过jdk中PhantomReference实现，无发通过该引用获取一个对象实例，唯一的目的是用来在回收时收到一条系统消息。
