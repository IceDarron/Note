Q：jvm运行时数据区。
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_data_zone.png)
### 程序计数器
>程序计数器是一块较小的内存空间，每个线程私有，作为当前线程所执行的字节码行号指示器。且如果执行java方法计数器记录，如果执行native方法则计数器值为空。
### java虚拟机栈
>用于描述java方法执行的内存模型，每个方法执行的时候创建一个栈帧，用于存储局部变量，操作数栈，动态链接，方法出口信息等。每一个方法调用至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量可以存储八大基本数据类型及对象引用类型。
### 本地方法栈
>相对于java虚拟机栈，本栈调用的方法为native方法服务。
### java堆
>java虚拟机管理的最大一块内存，所有线程共享，在虚拟机启动的时候创建，只用来存放对象实例。也是GC关注的主要区域。可以分为新生代（Eden，From survivor， To Survivor）和老年代。堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。
### 方法区
>所有线程共享，存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
### 运行时常量池
>这部分内容在来加载后进入方法区。

### 直接内存
>是一种堆外内存，通过一个存储在java堆中的DirecByteBuffer对象作为这个内存的引用进行操作，是由native函数库直接分配的内存，这样可以减少java堆和native堆之间来回复制数据。

Q：对象创建
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_create_object.png)
创建的关键字为new。当虚拟机遇到一个new指令时，会进行一下操作：
1. 检查指令参数是否在常量池中可以定位到一个类的符号引用，并检查所代表的类是否已经被加载、解析和初始化过，如果没有则先执行相应的类加载过程。
2. 为新生对象分配内存。有两种方式：指正碰撞（堆内存绝对规整，通过移动分界指针分配内存），空闲列表（堆内存不规整，维护一个列表，记录内存可用地方）。堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。由于堆是线程共享，所以需要考虑分配内存是，多线程问题。一是通过CAS加失败重试的方法保证分配内存空间的操作的原子性。二是通过对每个线程预先分配堆内存的缓冲区。
3. 对分配完成后的内存空间进行初始化为零值。
4. 虚拟机对对象进行必要设置，主要设置对象内存头的信息。
5. 虚拟机已经产生一个新的对象，最后执行程序编写中的init方法。

Q：对象的内存布局
===
对象在内存中存储的布局分为三块区域：对象头，实例数据，对齐填充。
对象头：分为两部分，第一部分用于存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态等。第二部分是类型指针，即对象指向它的类元数据的指针。
实例数据：对象真正存储的有效信息，即程序中定义的各种类型字段内容。无论父类继承还是子类定义，都记录。
对齐填充：自动内存管理系统要求对象起始地址必须是8字节的倍数。

Q：对象的访问定位
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_obj_visit.png)
栈中存放的引用类型，只规定了一个指向对象的引用，具体如何定位，由虚拟机实现，主要有两种方式：使用句柄，直接指针。（句柄可以理解为指向指针的指针，维护指向对象的指针的变化，对象的句柄本身不变化）

Q：对象是否可回收
===
1. 引用计数算法：通过计数器，引用+1，失效-1，为0时认为不可用。简单高效，但是很难解决对象之间相互循环引用的问题。
2. 可达性分析算法：通过GC Roots对象作为起点，向下搜索形成引用链，如果一个对象到GC Roots之间没有引用链，则认为不可用。GC 
3. Roots包括：虚拟机栈中引用的对象，方法去中类静态属性引用的对象，方法去中常量引用的对象，native方法引用的对象。
4. 可达性分析算法需要至少经历两次标记过程，如果不可达则进行标记并进行筛选（筛选条件为是否有必要执行finalize()方法，当没有重写或已经被虚拟机调用了则认为是没有必要执行），对于需要执行的情况下，则在finalize()方法中可以重新与引用链上的任意对象项链，将会被移除出即将回收的集合，从而避免回收。需要注意的是，任何一个对象的finalize方法只会被系统自动调用一次。不建议这么使用finalize方法，甚至不建议在程序中使用该方法。

Q：引用
===
+ 强引用：例如Object obj = new Object()，强引用存在，则永远不回收。
+ 软引用：通过jdk中SoftReference实现，在发生内存溢出异常之前，进行二次回收。
+ 弱引用：通过jdk中WeakReference实现，只生存到下次垃圾收集发生之前。无论内存是否足够，垃圾收集发生后都回收。
+ 虚引用：通过jdk中PhantomReference实现，无发通过该引用获取一个对象实例，唯一的目的是用来在回收时收到一条系统消息。

Q：垃圾收集算法
===
1. 标记-清除算法
先标记后清除，标记的时候会停顿所有线程。最基础的收集算法，但是效率较低，并且回收后的内存空间不连续，存在大连不连续内存碎片。影响分配大对象。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_gc_mark_sweep.png)
2. 复制算法
内存分为两部分，运行时使用其中一部分，当发起回收时，将存活对象复制到空白内存部分，并清除原先使用的部分。简单高效，空间连续。但是损失内存空间。
经IBM研究新生代98%的对象朝生夕死，所以将new内存分为8:1:1（Eden，From Survivor，To Survivor），每次使用Eden和From Survivor，回收时将存活的对象放到To Survivor上（据说清理后会将To与From交换，保证每次GC后使用的都是Eden和From，回收复制时放置的地方总是To），并清理其他部分。如果Survivor空间不足则需要依赖old部分进行分配担保。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_gc_copying.png)
3. 标记-整理算法
在标记-清除算法基础上，在标记阶段后不直接清除，而是让所有存活对象都向一端移动（整理），然后清除掉整理边界以外的内存。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_gc_mark_compact.png)
4. 分代收集算法
是一种针对将内存分为不同区域，各个区域使用自己合适的收集算法，通常java堆分为new和old（新生代，老年代），new使用复制算法，old使用标记-xx算法。


Q：HotSpot的算法实现
===
1. 枚举根节点
为可达性分析做准备，必须停顿所有java执行线程，通过一组成为OopMap的数据结构得知哪些地方存放着对象引用。
2. 安全点
对于达到安全点的地方记录指令并存入OopMap中。通常有抢先式中断（基本已弃用）和主动式中断。抢先式中断：GC发生，首先发所有线程中断，发现中断的地方不在安全点则回复线程并跑到安全点。主动式中断，设置一个标志位，当需要中断时修改标志位，并让线程主动轮询标志位，在中断。标志位本身与安全点重合。
3. 安全区域
对于处于sleep和block的线程无法响应jvm中断请求，这些线程会进入安全区域，安全区域线程可以GC。当离开安全区域时，需要检查系统是否完成枚举根节点或GC，如果完成则线程继续执行，否则等待。
