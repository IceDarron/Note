Q:Java IO
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/java_io.png)

### File类
> File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。  

### 流的概念和作用
> 流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 

### IO流的分类
+ 根据处理数据类型的不同分为：字符流和字节流
+ 根据数据流向不同分为：输入流和输出流

### 字符流和字节流
> 字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：
读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。
处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。
结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。

### 输入流和输出流
> 对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。

### Java IO流对象
> 输入字节流InputStreamIO 中输入字节流的继承图可见上图，可以看出：
+ InputStream 是所有的输入字节流的父类，它是一个抽象类。
+ ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据。
+ ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。
> 输出字节流OutputStreamIO 中输出字节流的继承图可见上图，可以看出：
+ OutputStream 是所有的输出字节流的父类，它是一个抽象类。
+ ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据。
+ ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。

### 字符输入流Reader
+ Reader 是所有的输入字符流的父类，它是一个抽象类。
+ CharReader、StringReader是两种基本的介质流，它们分别将Char数组、String中读取数据。PipedReader是从与其它线程共用的管道中读取数据。
+ BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。
+ FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。
+ InputStreamReader是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。

### 字符输出流Writer
+ Writer 是所有的输出字符流的父类，它是一个抽象类。
+ CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据。
+ BufferedWriter 是一个装饰器为Writer 提供缓冲功能。
+ PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。
+ OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似。

### 字符流与字节流转换
InputStreamReader:字节到字符的桥梁
OutputStreamWriter:字符到字节的桥梁
这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。

### RandomAccessFile
> 该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：
只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。
既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)

### 提供部分不完整代码，例如流关闭应该全部在finally里处理
```Java
try {
    char[] buffer = new char[1024];
    FileReader fr = new FileReader("testr.txt");
    FileWriter fw = new FileWriter("testw.txt");
    int numberRead = 0;

    while ((numberRead = fr.read(buffer))!=-1) {
        fw.write(buffer, 0, numberRead);
    }
    fr.close();
    fw.close();
} catch (IOException e) {
    e.printStackTrace();
}

try {
    int index = 0;
    byte[] buffer = new byte[1024];
    File fileOrign = new File("testo.txt");
    File fileCopy = new File("testc.txt");
    InputStream is = new FileInputStream(fileOrign);
    OutputStream os = new FileOutputStream(fileCopy);

    while ((index = is.read(buffer)) != -1) {
        os.write(buffer);
    }
    is.close();
    os.close();
} catch (Exception e) {
    e.printStackTrace();
}

try {
    FileReader fr = new FileReader("test.txt");
    BufferedReader br = new BufferedReader(fr);
    String str = "";

    while ((str = br.readLine()) != null) {
        System.out.println(str);
    }
    fr.close();
} catch (IOException e) {
    e.printStackTrace();
}
```

Q:Java NIO
===
### 简介
> Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。Java NIO 核心部分组成：Channels，Buffers，Selectors。
#### Java NIO: Channels and Buffers（通道和缓冲区）
> 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
#### Java NIO: Non-blocking IO（非阻塞IO）
> Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。
#### Java NIO: Selectors（选择器）
> Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。

### Channel
> Channel类似流，但又有些不同：
+ 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。
+ 通道可以异步地读写。
+ 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。
> Channel的主要实现，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。
+ FileChannel 从文件中读写数据。
+ DatagramChannel 能通过UDP读写网络中的数据。
+ SocketChannel 能通过TCP读写网络中的数据。
+ ServerSocketChannel 可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。

``` Java
try {
    RandomAccessFile aFile = new RandomAccessFile("test.txt", "rw");
    FileChannel inChannel = aFile.getChannel();

    ByteBuffer buf = ByteBuffer.allocate(1024);

    int bytesRead = inChannel.read(buf);
    while (bytesRead != -1) {

        System.out.println("Read " + bytesRead);
        buf.flip();

        while (buf.hasRemaining()) {
            System.out.print((char) buf.get());
        }

        buf.clear();
        bytesRead = inChannel.read(buf);
    }
    aFile.close();
} catch (IOException e) {
    e.printStackTrace();
} finally {
}
``` 

### Buffer
![Image text](https://github.com/IceDarron/Note/blob/master/Image/java_nio_capacity&position&limi.png)
> 使用Buffer读写数据一般遵循以下四个步骤：
+ 写入数据到Buffer
+ 调用flip()方法
+ 从Buffer中读取数据
+ 调用clear()方法或者compact()方法
> 当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。
一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。

#### capacity,position和limit详解
> 缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。读写涉及到的主要三个属性，详细如下：
##### capacity
> 作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。

##### position
> 当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.
当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。

##### limit
> 在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。
当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）

#### flip()方法,从写模式切换到读模式
``` Java
public final Buffer flip() {
        limit = position;
        position = 0;
        mark = -1;
        return this;
    }
```

#### rewind()方法, 重读Buffer中的所有数据
``` Java
public final Buffer rewind() {
        position = 0;
        mark = -1;
        return this;
    }
```

#### clear()方法,准备好再次被写入
``` Java
public final Buffer clear() {
        position = 0;
        limit = capacity;
        mark = -1;
        return this;
    }
```

### Scatter/Gather
> scatter/gather用于描述从Channel中读取或者写入到Channel的操作。

> 分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。

> 聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。

>scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。

#### Scattering Reads
> Scattering Reads是指数据从一个channel读取到多个buffer中。注意buffer首先被插入到数组，然后再将数组作为channel.read()的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。

#### Gathering Writes
> Gathering Writes是指数据从多个buffer写入到同一个channel。buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。

``` Java
// catter&gather demo
public static void catterAndGather() throws Exception{
    RandomAccessFile raf1 = new RandomAccessFile("a.txt", "rw");
    //获取通道
    FileChannel channel1 = raf1.getChannel();
    //设置缓冲区
    ByteBuffer buf1 = ByteBuffer.allocate(50);
    ByteBuffer buf2 = ByteBuffer.allocate(1024);
    //分散读取的时候缓存区应该事有序的，所以把几个缓冲区加入数组中
    ByteBuffer[] bufs = {buf1, buf2};
    //通道进行传输
    channel1.read(bufs);

    //查看缓冲区中的内容
    for (int i = 0; i < bufs.length; i++) {
        //切换为读模式
        bufs[i].flip();
    }

    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));
    System.out.println();
    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));

    //聚集写入
    RandomAccessFile raf2 = new RandomAccessFile("b.txt", "rw");
    FileChannel channel2 = raf2.getChannel();
    //只能通过通道来进行写入
    channel2.write(bufs);
}
```

### 通道之间的数据传输
> 在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。

#### transferFrom()
> FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。

#### transferTo()
> transferTo()方法将数据从FileChannel传输到其他的channel中。

> 方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。
此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。

### Selector
> Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。

``` Java
Selector selector = Selector.open();
// 与Selector一起使用时，Channel必须处于非阻塞模式下。
// 这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。
// 而套接字通道都可以。
channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);

while(true) {

	int readyChannels = selector.select();
	if(readyChannels == 0) continue;

	Set selectedKeys = selector.selectedKeys();
	Iterator keyIterator = selectedKeys.iterator();

	while(keyIterator.hasNext()) {
	  SelectionKey key = keyIterator.next();

	  if(key.isAcceptable()) {
	      // a connection was accepted by a ServerSocketChannel.
	  } else if (key.isConnectable()) {
	      // a connection was established with a remote server.
	  } else if (key.isReadable()) {
	      // a channel is ready for reading
	  } else if (key.isWritable()) {
	      // a channel is ready for writing
	  }

	  keyIterator.remove();
	}
}
```

#### SelectionKey
> 当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。包含了许多属性，一下一一介绍。

##### interest集合
+ SelectionKey.OP_CONNECT
+ SelectionKey.OP_ACCEPT
+ SelectionKey.OP_READ
+ SelectionKey.OP_WRITE
> 如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：

``` Java
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
```

> 通过位与运算确定某个事件是否在interest集合中。

``` Java
int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = (interestSet & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；
boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE;
```

##### ready集合
> 表示通道是否已经准备就绪的操作的集合。

``` Java
int readySet = selectionKey.readyOps();

selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
```

##### Channel + Selector
> 通过SelectionKey访问Channel和Selector。

``` Java
Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();
```

##### 附加的对象
> 可以给每个SelectionKey对象附加信息，方便识别每个通道。

``` Java
selectionKey.attach(theObject);

Object attachedObj = selectionKey.attachment();

SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
```

### Pipe
> Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。
这里是Pipe原理的图示：

![Image text](https://github.com/IceDarron/Note/blob/master/Image/java_nio_pipe.png)

#### 创建管道

``` Java
Pipe pipe = Pipe.open();
```

#### 向管道写数据

``` Java
Pipe.SinkChannel sinkChannel = pipe.sink();

String newData = "New String to write to file..." + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);

buf.clear();
buf.put(newData.getBytes());
buf.flip();

while(buf.hasRemaining()) {
    sinkChannel.write(buf);
}
```

#### 从管道读取数据

``` Java
Pipe.SourceChannel sourceChannel = pipe.source();
ByteBuffer buf = ByteBuffer.allocate(48);
// read()方法返回的int值会告诉我们多少字节被读进了缓冲区。
int bytesRead = sourceChannel.read(buf);
```

Q:Java NIO与IO
===
|IO              |NIO
| ------------- |-------------:|
|面向流          |面向缓冲      |
|阻塞IO          |非阻塞IO      |
|无              |选择器        |

### 面向流与面向缓冲
> Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

### 阻塞与非阻塞IO
> Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

### 选择器（Selectors）
> Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

### NIO和IO如何影响应用程序的设计
+ 对NIO或IO类的API调用。
+ 数据处理。
+ 用来处理数据的线程数。


Q:Java反射
===
### 反射机制概念
> 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。在java中，只要给定类的名字， 那么就可以通过反射机制来获得类的所有信息。
反射是Java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！
类中有什么信息，利用反射机制就能可以获得什么信息，不过前提是得知道类的名字。

### 反射机制的作用
+ 在运行时判断任意一个对象所属的类；
+ 在运行时获取类的对象；
+ 在运行时访问java对象的属性，方法，构造方法等。

### 反射机制的优点与缺点
> 首先要搞清楚为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念。 
静态编译：在编译时确定类型，绑定对象，即通过。 
动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 
反射机制的优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行了反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。
比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 
反射机制的缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它 满足我们的要求。这类操作总是慢于只直接执行相同的操作。

### java中有三种类类加载器
+ Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。
+ Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类
+ AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。
> 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。

### 类的生命周期
> 在一个类编译完成之后，下一步就需要开始使用类，如果要使用一个类，肯定离不开JVM。在程序执行中JVM通过装载，链接，初始化这3个步骤完成。
类的装载是通过类加载器完成的，加载器将.class文件的二进制文件装入JVM的方法区，并且在堆区创建描述这个类的java.lang.Class对象。用来封装数据。 但是同一个类只会被类装载器装载一次。
链接就是把二进制数据组装为可以运行的状态。
链接分为校验，准备，解析这3个阶段：
校验一般用来确认此二进制文件是否适合当前的JVM（版本），
准备就是为静态成员分配内存空间，。并设置默认值
解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系）。
完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收。释放空间。当没有任何引用指向Class对象时就会被卸载，结束类的生命周期。

### IoC原理
> Spring中的IoC的实现原理就是工厂模式加反射机制。

#### 不用反射机制时的工厂模式：
``` Java
/**
 * 工厂模式
 */
interface fruit{
    public abstract void eat();
}

class Apple implements fruit{
    public void eat(){
        System.out.println("Apple");
    }
}

class Orange implements fruit{
    public void eat(){
        System.out.println("Orange");
    }
}
// 构造工厂类
// 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了
class Factory{
    public static fruit getInstance(String fruitName){
        fruit f=null;
        if("Apple".equals(fruitName)){
            f=new Apple();
        }
        if("Orange".equals(fruitName)){
            f=new Orange();
        }
        return f;
    }
}

class hello{
    public static void main(String[] a){
        fruit f=Factory.getInstance("Orange");
        f.eat();
    }
}
```
> 当我们在添加一个子类的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改的就会很多。先不考虑更高级的抽象工厂。

#### 利用反射机制的工厂模式：
``` Java
package Reflect;

interface fruit{
    public abstract void eat();
}

class Apple implements fruit{
    public void eat(){
        System.out.println("Apple");
    }
}

class Orange implements fruit{
    public void eat(){
        System.out.println("Orange");
    }
}

class Factory{
    public static fruit getInstance(String ClassName){
        fruit f=null;
        try{
            f=(fruit)Class.forName(ClassName).newInstance();
        }catch (Exception e) {
            e.printStackTrace();
        }
        return f;
    }
}

class hello{
    public static void main(String[] a){
        fruit f=Factory.getInstance("Reflect.Apple");
        if(f!=null){
            f.eat();
        }
    }
}
```
>现在就算我们添加任意多个子类的时候，工厂类就不需要修改。使用反射机制的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。

#### 使用反射机制并结合属性文件的工厂模式（即IoC）

> 首先创建一个fruit.properties的资源文件：
``` Java
apple=Reflect.Apple
orange=Reflect.Orange
```
``` Java
package Reflect;

import java.io.*;
import java.util.*;

interface fruit{
    public abstract void eat();
}

class Apple implements fruit{
    public void eat(){
        System.out.println("Apple");
    }
}

class Orange implements fruit{
    public void eat(){
        System.out.println("Orange");
    }
}
//操作属性文件类
class init{
    public static Properties getPro() throws FileNotFoundException, IOException{
        Properties pro=new Properties();
        File f=new File("fruit.properties");
        if(f.exists()){
            pro.load(new FileInputStream(f));
        }else{
            pro.setProperty("apple", "Reflect.Apple");
            pro.setProperty("orange", "Reflect.Orange");
            pro.store(new FileOutputStream(f), "FRUIT CLASS");
        }
        return pro;
    }
}

class Factory{
    public static fruit getInstance(String ClassName){
        fruit f=null;
        try{
            f=(fruit)Class.forName(ClassName).newInstance();
        }catch (Exception e) {
            e.printStackTrace();
        }
        return f;
    }
}

class hello{
    public static void main(String[] a) throws FileNotFoundException, IOException{
        Properties pro=init.getPro();
        fruit f=Factory.getInstance(pro.getProperty("apple"));
        if(f!=null){
            f.eat();
        }
    }
}
//【运行结果】：Apple
```

Q:springBean的生命周期
===
![Image text](https://github.com/IceDarron/Note/blob/master/Image/spring_bean_life_cycle.png)

Q:Java序列化与反序列化
===
>  Java序列化就是把对象转换成字节序列，而Java反序列化就是把字节序列还原成Java对象。
采用Java序列化与反序列化技术，一是可以实现数据的持久化，在MVC模式中很是有用；二是可以对象数据的远程通信。

### 序列化与反序列化的实现
#### JDK类库中序列化API
> java.io.ObjectOutputStream：表示对象输出流，它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。
java.io.ObjectInputStream：表示对象输入流，它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。

#### 实现Serializable或Externalizable接口
方法一：实现了Serializable接口，则可以按照以下方式进行序列化和反序列化
ObjectOutputStream采用默认的序列化方式，对对象的非transient的实例变量进行序列化。
ObjcetInputStream采用默认的反序列化方式，对对象的非transient的实例变量进行反序列化。
方法二：若类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。
ObjectOutputStream调用对象的writeObject(ObjectOutputStream out)的方法进行序列化。
ObjectInputStream会调用对象的readObject(ObjectInputStream in)的方法进行反序列化。
方法三：若类实现了Externalnalizable接口，且类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法。


Q:常用设计模式。
===
### 设计模式分为三大类
+ 创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 
+ 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 
+ 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 
+ 其实还有两类：并发型模式和线程池模式

### 1.工厂方法模式 
> 工厂方法模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建 
多个工厂方法模式：是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。

### 2.抽象工厂模式（Abstract Factory） 
工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。

### 3.单例模式（Singleton） 
> 单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 
1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 
2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 
3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。

### 4.建造者模式（Builder） 
> 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。 
工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。

### 5.原型模式（Prototype） 
> 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。

### 6.适配器模式（Adapter） 
> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式

### 7.装饰模式（Decorator） 
> 顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 
装饰器模式的应用场景： 
1、需要扩展一个类的功能。 
2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 
缺点：产生过多相似的对象，不易排错！

### 8.代理模式（Proxy） 
> 其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作。 
代理模式的应用场景： 
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

### 9.外观模式（Facade） 
> 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。

### 10.桥接模式（Bridge） 
> 桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。

### 11.组合模式（Composite） 
> 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便。 
使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。

### 12.享元模式（Flyweight） 
> 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 
一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。

### 13.策略模式（strategy） 
> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。 
策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。

### 14.模板方法模式（Template Method） 
> 解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。

### 15、观察者模式（Observer） 
> 都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。

### 16.迭代器模式（Iterator） 
> 顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。

### 17.责任链模式（Chain of Responsibility） 
> 接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。 
此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。

### 18.命令模式（Command） 
> 命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。

### 19.备忘录模式（Memento） 
> 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。

### 20.状态模式（State） 
> 核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。

### 21.访问者模式（Visitor） 
> 访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。 
简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 
该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦。

### 22.中介者模式（Mediator） 
> 中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。

### 23.解释器模式（Interpreter） 
> 一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。
