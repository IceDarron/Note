Q：消息队列MQ
===
>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。
通过消息队列，应用程序可独立地执行--它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。
在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。
消息队列为构造以同步或异步方式实现的分布式应用提供了松耦合方法。
消息队列的API调用被嵌入到新的或现存的应用中，通过消息发送到内存或基于磁盘的队列或从它读出而提供信息交换。
消息队列可用在应用中以执行多种功能，比如要求服务、交换信息或异步处理等。

#### MQ的通讯模式
+ 点对点通讯：点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。
+ 多点广播：MQ适用于不同类型的应用。其中重要的，也是正在发展中的是"多点广播"应用，即能够将消息发送到多个目标站点(Destination List)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。
+ 发布/订阅(Publish/Subscribe)模式：发布/订阅功能使消息的分发可以突破目的队列地理指向的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅功能使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。在MQ家族产品中，MQ Event Broker是专门用于使用发布/订阅技术进行数据通讯的产品，它支持基于队列和直接基于TCP/IP两种方式的发布和订阅。
+ 群集(Cluster)：为了简化点对点通讯模式中的系统配置，MQ提供Cluster(群集)的解决方案。群集类似于一个域(Domain)，群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集(Cluster)通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。


#### Kafka
![Image text](https://github.com/IceDarron/Note/blob/master/Image/kafka_topic.png)
>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。
Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：
+ 通过磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）
+ 高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。
+ 支持通过Kafka服务器和消费机集群来分区消息。
+ 支持Hadoop并行数据加载。
+ Broker:：Kafka集群包含一个或多个服务器，这种服务器被称为broker(代理)。
+ Topic：话题是特定类型的消息流。每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）
+ Partition：是物理上的概念，每个Topic包含一个或多个Partition.
+ Producer：负责发布消息到Kafka broker
+ Consumer：消息消费者，向Kafka broker读取消息的客户端。
+ Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。
+ 一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用。


#### RocketMQ
>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 沈询
>RocketMQ认为消息队列为了保持高吞吐，海量数据，低延迟，数据安全等，故在一些异常等小概率事件处理上保持不解决的态度，这些事件应当在消费端（业务逻辑）中处理。其实也就是设计模式中的单一职责原则，未来的技术或系统等，在性能不能从硬件上发生根本的变化时，将会功能越来越单一。
+ 顺序消息：在同一个分区（queue）下保持顺序，同一个分区下是FIFO。但是消息发送默认是采用轮训的方式发送到不同的分区。通过一个连续消息共用的id取模获取同一个queue（类似于桶的概念）。
+ 消息重复：RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。处理的两个方面：消费端处理消息的业务逻辑保持幂等性。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。
+ 事务消息：大事务 = 小事务 + 异步。尽量不在消息队列中处理回滚等操作。
+ Producer如何发送消息：轮询某topic下的所有队列的方式来实现发送方的负载均衡。如果Producer发送消息失败，会自动重试，重试的策略：重试次数 < retryTimesWhenSendFailed（可配置）。总的耗时（包含重试n次的耗时） < sendMsgTimeout（发送消息时传入的参数）。同时满足上面两个条件后，Producer会选择另外一个队列发送消息。
+ 消息存储：RocketMQ的消息存储是由consume queue和commit log配合完成的。consume queue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。
+ 消息订阅：RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送；另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式。
+ 定时消息
+ 消息的刷盘策略
+ 主动同步策略：同步双写、异步复制
+ 海量消息堆积能力
+ 高效通信


#### ActiveMQ     
>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
ActiveMQ特性如下：
+ 多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP
+ 完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)
+ 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性
+ 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上
+ 支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA
+ 支持通过JDBC和journal提供高速的消息持久化
+ 从设计上保证了高性能的集群，客户端-服务器，点对点
+ 支持Ajax
+ 支持与Axis的整合
+ 可以很容易得调用内嵌JMS provider，进行测试


#### 参考资料
+ MQ使用场景&对比: https://blog.csdn.net/HD243608836/article/details/80217591
