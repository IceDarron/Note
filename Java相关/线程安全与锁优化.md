Q：线程安全与锁优化
===
+ 当多个线程访问同一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
+ 通常有五种级别的线程安全：不可变，绝对线程安全，相对线程安全，线程兼容，线程对立。
+ 线程安全的实现方式：互斥同步（synchronized和reentrantlock），非阻塞同步（CAS等），无同步方案（可重用代码和线程本地存储，本身无共享数据）
+ 锁优化：为了线程之间更高效的共享数据，解决竞争问题。
+ 自旋锁与自适应自旋：由于挂起线程和恢复线程需要在内核态完成，很浪费性能，并且共享数据的锁定通常持续时间很短，所以通过减少不必要的挂起和恢复，通过让线程执行一个忙循环（自旋），使线程不放弃cpu占用时间，让后续线程等待锁。自旋等待不等于代替阻塞。自旋等待的效果取决于锁占用的时间是否很短，时间短效果好。自适应自旋是自旋的升级版，通过前一个同一个锁上的自旋时间及锁拥有者的状态自动调整自旋时间。
+ 锁消除：虚拟机即时编译器运行时通过逃逸分析的数据支持，检测到不可能存在共享的数据竞争的锁，从而进行消除。例如方法参数为多个string，方法体为参数相加，编译器会自动优化为stringbuffer的append，所以造成了无用的锁。
+ 锁粗化：对一个对象循环进行连续同步操作，可以把加锁同步的范围扩大到整个操作序列的外部。
+ 轻量级锁：在考虑绝大部分锁，在整个同步周期内不存在竞争才能提升性能。通过对象的内存布局，CAS等来操作，如果竞争则开销更大。不能代替重量级锁。
+ 偏向锁：偏向第一个持有该锁的线程，并在该锁没有被其他线程获得的情况下，持有该偏向锁的线程不需要进行同步。如果获取该锁，则偏向模式结束，恢复到未锁定或轻量级锁状态。
+ 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_biased_lock.png)
![Image text](https://github.com/IceDarron/Note/blob/master/Image/jvm_light_lock.png)

|锁      |优点     |缺点      |适用场景|
|--------|---------|---------|---------|
|偏向锁   |加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距|如果线程间存在锁竞争，会带来额外的锁撤销的消耗|适用于只有一个线程访问同步块场景|
|轻量级锁 |竞争的线程不会阻塞，提高了程序的响应速度|如果始终得不到锁竞争的线程使用自旋会消耗CPU|追求响应时间,锁占用时间很短|
|重量级锁 |线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量,锁占用时间较长|