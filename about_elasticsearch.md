下载
===
hadoop官网：http://hadoop.apache.org/releases.html#Download

安装
===

启动停止及常用查询
===

ES基本概念
ElasticSearch(简称ES)是一个基于Lucene构建的开源、分布式、RESTful的全文本搜索引擎。
同时，它还是一个分布式实时文档存储，其中每个field均是被索引的数据且可被搜索；
也是一个带实时分析功能的分布式搜索引擎，并且能够扩展至数以百计的服务器存储及处理PB级的数据。
===
### 索引(Index)
ES将数据存储于一个或多个索引中，索引是具有类似特性的文档的集合。
类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库，或者一个数据存储方案(schema)。
索引由其名称(必须为全小写字符)进行标识，并通过引用此名称完成文档的创建、搜索、更新及删除操作。
一个ES集群中可以按需创建任意数目的索引。

### 类型(Type)
类型是索引内部的逻辑分区(category/partition)，然而其意义完全取决于用户需求。
因此，一个索引内部可定义一个或多个类型(type)。一般来说，类型就是为那些拥有相同的域的文档做的预定义。
例如，在索引中，可以定义一个用于存储用户数据的类型，一个存储日志数据的类型，以及一个存储评论数据的类型。
类比传统的关系型数据库领域来说，类型相当于“表”。

### 文档(Document)
文档是Lucene索引和搜索的原子单位，它是包含了一个或多个域的容器，基于JSON格式进行表示。
文档由一个或多个域组成，每个域拥有一个名字及一个或多个值，有多个值的域通常称为“多值域”。
每个文档可以存储不同的域集，但同一类型下的文档至应该有某种程度上的相似之处。

### 映射(Mapping)
ES中，所有的文档在存储之前都要首先进行分析。
用户可根据需要定义如何将文本分割成token、哪些token应该被过滤掉，以及哪些文本需要进行额外处理等等。
另外，ES还提供了额外功能，例如将域中的内容按需排序。事实上，ES也能自动根据其值确定域的类型。

### 集群(Cluster)
ES集群是一个或多个节点的集合，它们共同存储了整个数据集，并提供了联合索引以及可跨所有节点的搜索能力。
多节点组成的集群拥有冗余能力，它可以在一个或几个节点出现故障时保证服务的整体可用性。
集群靠其独有的名称进行标识，默认名称为“elasticsearch”。
节点靠其集群名称来决定加入哪个ES集群，一个节点只能属一个集群。
如果不考虑冗余能力等特性，仅有一个节点的ES集群一样可以实现所有的存储及搜索功能。

### 节点(Node)
运行了单个实例的ES主机称为节点，它是集群的一个成员，可以存储数据、参与集群索引及搜索操作。
类似于集群，节点靠其名称进行标识，默认为启动时自动生成的随机Marvel字符名称。
用户可以按需要自定义任何希望使用的名称，但出于管理的目的，此名称应该尽可能有较好的识别性。
节点通过为其配置的ES集群名称确定其所要加入的集群。

### 分片(Shard)和副本(Replica)
ES的“分片(shard)”机制可将一个索引内部的数据分布地存储于多个节点，
它通过将一个索引切分为多个底层物理的Lucene索引完成索引数据的分割存储功能，
这每一个物理的Lucene索引称为一个分片(shard)。
每个分片其内部都是一个全功能且独立的索引，因此可由集群中的任何主机存储。
创建索引时，用户可指定其分片的数量，默认数量为5个。
Shard有两种类型：primary和replica，即主shard及副本shard。
Primary shard用于文档存储，每个新的索引会自动创建5个Primary shard，当然此数量可在索引创建之前通过配置自行定义，
不过，一旦创建完成，其Primary shard的数量将不可更改。
Replica shard是Primary Shard的副本，用于冗余数据及提高搜索性能。
每个Primary shard默认配置了一个Replica shard，但也可以配置多个，且其数量可动态更改。
ES会根据需要自动增加或减少这些Replica shard的数量。
ES集群可由多个节点组成，各Shard分布式地存储于这些节点上。
ES可自动在节点间按需要移动shard，例如增加节点或节点故障时。
简而言之，分片实现了集群的分布式存储，而副本实现了其分布式处理及冗余功能。

elasticsearch与关系数据库对比
===
Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式。

其结构相对于关系数据库的对比如下：

关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)

Elasticsearch ⇒ 索引 ⇒ 类型 ⇒ 文档 ⇒ 字段(Fields)

lucene全文检索
===


倒排索引
===
https://github.com/IceDarron/Note/blob/master/201802.md

索引模型：

### Posting List
Elasticsearch分别为每个field都建立了一个倒排索引，Posting list就是一个int的数组，存储了所有符合某个term的文档id。

### Term Dictionary
Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。

### Term Index
 B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，
 但是如果term太多，term dictionary也会很大，放内存不现实，
 于是有了Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树：
 
![session](https://github.com/IceDarron/Note/blob/master/Image/elasticsearch_term_index.png)

这棵树不会包含所有的term，它包含的是term的一些前缀。
通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。

### 不可变性
写入磁盘的倒排索引是不可变的，它有如下好处：

+ 不需要锁。如果从来不需要跟新一个索引，就不必担心多个程序见同时尝试修改。
+ 一旦索引被读入文件系统的缓存，它就一直在那儿，因为不会改变。只要文件系统缓存有足够的空间，大部分的读会直接访问内存而不是磁盘。这有助于性能的提升。
+ 在索引的声明周期内，所有的其他缓存都可用。他们不需要再每次数据变化了都重建，因此数据不会变。
+ 写入单个大的倒排索引，可以压缩数据，较少的磁盘IO和需要缓存索引的大小。

当然，不可变的索引有它的缺点，首先是它不可变。
如果想要搜索一个新文档，必须重建整个索引。
这不仅限制了一个索引所能装下的数据，还有一个索引可以被更新的频次。

二元搜索算法
===
二元搜索算法是在排好序的数组中找到特定的元素

首先, 比较数组中间的元素,如果相同,则返回此元素的指针,表示找到了. 
如果不相同, 此函数就会继续搜索其中大小相符的一半,然后继续下去. 
如果剩下的数组长度为0, 则表示找不到,函数就会结束.

此算法函数如下:

```java
public class elasticsearch {
    int binarySearch(int val, int array[], int n)
    {
        int m = n/2;
        if(n <= 0) return NULL;
        if(val == array[m]) return array + m;
        if(val < array[m]) return binarySearch(val, array, m);
        else return binarySearch(val, array+m+1, n-m-1);
    }
}
```

对于有n个元素的数组来说,二元搜索算法进行最多1+log2(n)次比较. 如果有一百万元素,最比较20次, 也就是最多20次递归执行binarySearch()函数.


压缩算法
===
首先，对词典文件中的关键词进行了压缩，关键词压缩为<前缀长度，后缀>，
例如：当前词为“阿拉伯语”，上一个词为“阿拉伯”，那么“阿拉伯语”压缩为<3，语>。

ab				(vint) 0 ab

abcd			(vint) 2 cd

abcde			(vint) 4 e

其次大量用到的是对数字的压缩，数字只保存与上一个值的差值（这样可以减少数字的长度，进而减少保存该数字需要的字节数）。
例如当前文章号是16389（不压缩要用3个字节保存），上一文章号是16382，压缩后保存7（只用一个字节）。


Elasticsearch是如何实现Master选举的
===
+ Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；
+ 对所有可以成为master的节点（node.master: true）根据nodeId字典排序，
   每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。
+ 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。
+ 补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。



参考资料
===
http://ginobefunny.com/post/elasticsearch_interview_questions/