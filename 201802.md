Q:MapReduce
===
MapReduce其实是分治算法的一种实现，所谓分治算法就是“就是分而治之”，将大的问题分解为相同类型的子问题（最好具有相同的规模），对子问题进行求解，然后合并成大问题的解。MapReduce就是分治法的一种，将输入进行分片，然后交给不同的task进行处理，然后合并成最终的解。

![mapreduce模型](https://github.com/IceDarron/Note/blob/master/Image/mapReduce_model.png)

![mapreduce模型](https://github.com/IceDarron/Note/blob/master/Image/mapReduce_model0.png)

### Map阶段
首先是读数据，数据来源可能是文本文件，表格，MySQL数据库。这些数据通常是成千上万的文件（叫做shards），这些shards被当做一个逻辑输入源。然后Map阶段调用用户实现的函数，叫做Mapper，独立且并行的处理每个shard。对于每个shard，Mapper返回多个键值对，这是Map阶段的输出。

### Shuffle阶段
把键值对进行归类，也就是把所有相同的键的键值对归为一类。这个步骤的输出是不同的键和该键的对应的值的数据流。

### Reduce阶段
输入当然是shuffle的输出。然后Reduce阶段调用用户实现的函数，叫做Reducer，对每个不同的键和该键的对应的值的数据流进行独立、并行的处理。每个reducer遍历键对应的值，然后对值进行“置换”。这些置换通常指的的是值的聚合或者什么也不处理，然后把键值对写入数据库、表格或者文件中。

本问题仅简单介绍，相关资料如下：http://blog.csdn.net/u010725690/article/details/53893667


Q:布隆过滤器 bloom filter
===
布隆过滤器（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的。它实际上是由一个很长的二进制向量和一系列随机映射函数组成，布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率。

直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

### 算法步骤
1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

![布隆过滤器结构](https://github.com/IceDarron/Note/blob/master/Image/bloom_filter.png)

### 优点
+ 不需要存储key，节省空间

### 缺点
+ 算法判断key在集合中时，有一定的概率key其实不在集合中
+ 无法删除

### Counting filters
> 基本的布隆过滤器不支持删除（Deletion）操作，但是 Counting filters 提供了一种可以不用重新构建布隆过滤器但却支持元素删除操作的方法。在Counting filters中原来的位数组中的每一位由 bit 扩展为 n-bit 计数器，实际上，基本的布隆过滤器可以看作是只有一位的计数器的Counting filters。原来的插入操作也被扩展为把 n-bit 的位计数器加1，查找操作即检查位数组非零即可，而删除操作定义为把位数组的相应位减1，但是该方法也有位的算术溢出问题，即某一位在多次删除操作后可能变成负值，所以位数组大小 m 需要充分大。另外一个问题是Counting filters不具备伸缩性，由于Counting filters不能扩展，所以需要保存的最大的元素个数需要提前知道。否则一旦插入的元素个数超过了位数组的容量，false positive的发生概率将会急剧增加。当然也有人提出了一种基于 D-left Hash 方法实现支持删除操作的布隆过滤器，同时空间效率也比Counting filters高。

### 较为成熟的实现
google的guava包中提供了BloomFilter类。


Q:倒排索引(inverted index)
===
倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成："单词词典"和"倒排文件"。其实倒排索引更恰当的应该翻译为倒置索引。
+ 单词词典(Lexicon)：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。
+ 倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。
+ 倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。

![倒排索引结构](https://github.com/IceDarron/Note/blob/master/Image/inverted_index.png)

例子：

![倒排索引例子0](https://github.com/IceDarron/Note/blob/master/Image/inverted_index_demo0.png)

![倒排索引例子1](https://github.com/IceDarron/Note/blob/master/Image/inverted_index_demo1.png)

+ 单词ID：记录每个单词的单词编号；
+ 单词：对应的单词；
+ 文档频率：代表文档集合中有多少个文档包含某个单词
+ 倒排列表：包含单词ID及其他必要信息
+ DocId：单词出现的文档id
+ TF：单词在某个文档中出现的次数
+ POS：单词在文档中出现的位置

> 以单词“加盟”为例，其单词编号为6，文档频率为3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为{(2;1;<4>),(3;1;<7>),(5;1;<5>)}，含义是在文档2，3，5出现过这个单词，在每个文档的出现过1次，单词“加盟”在第一个文档的POS是4，即文档的第四个单词是“加盟”，其他的类似。


Q:假如有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？
===
```java
package com.darron;

import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;

public class TestMultiThread {

    /**
     * 功能实现：核心类java.util.concurrent.CountDownLatch
     * CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。本质上来讲就是一个计数器
     * 其核心还是AQS，在此不多赘述。
     */
    public static void main(String[] args) {

        CountDownLatch countDownLatch = new CountDownLatch(4); // 设置线程数
        ExecutorService executorService = Executors.newCachedThreadPool();//线程池

        Future future0 = executorService.submit(new Worker("c", countDownLatch));
        Future future1 = executorService.submit(new Worker("d", countDownLatch));
        Future future2 = executorService.submit(new Worker("e", countDownLatch));
        Future future3 = executorService.submit(new Worker("f", countDownLatch));

        try {
            countDownLatch.await(); // 等待所有磁盘计算完毕
            executorService.shutdown(); // 提交所有任务
            int total = (int) future0.get() + (int) future1.get() + (int) future2.get() + (int) future3.get();
            System.out.println(total);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    // 实现Callable主要是为了能获取返回值
    public static class Worker implements Callable {

        private String cdName;

        private int cdCapacity;

        private CountDownLatch countDownLatch;

        public Worker() {
        }

        public Worker(String cdName, CountDownLatch countDownLatch) {
            this.cdName = cdName;
            this.countDownLatch = countDownLatch;
        }

        @Override
        public Object call() throws Exception {
            System.out.println("start calculate " + cdName);
            cdCapacity = cdName.charAt(0); // 模拟计算磁盘空间大小
            System.out.println("end calculate " + cdName + "capacity " + cdCapacity);
            countDownLatch.countDown(); // 计数器减一
            return cdCapacity;
        }
    }
}
```


Q:Java并发编程(Executor框架)
===
Eexecutor作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用Runnable来表示任务，Executor的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。

![Executor的UML图](https://github.com/IceDarron/Note/blob/master/Image/Executor_UML.png)

+ Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command),
+ ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法
+ AbstractExecutorService：ExecutorService执行方法的默认实现
+ ScheduledExecutorService：一个可定时调度任务的接口
+ ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池
+ ThreadPoolExecutor：线程池，可以通过调用Executors以静态工厂方式来创建线程池并返回一个ExecutorService对象

### Executor的生命周期
ExecutorService提供了管理Eecutor生命周期的方法，ExecutorService的生命周期包括了：运行  关闭和终止三种状态。

ExecutorService在初始化创建时处于运行状态。

shutdown方法等待提交的任务执行完成并不再接受新任务，在完成全部提交的任务后关闭

shutdownNow方法将强制终止所有运行中的任务并不再允许提交新任务

### ExecutorService 的submit（） 与execute（）区别 
+ 接收的参数不一样 submit（）可以接受runnable和callable  有返回值。execute（）接受runnable 无返回值
+ submit有返回值，而execute没有
+ submit方便Exception处理

### Executors
提供了一系列静态工厂方法用于创建各种线程池

### 通过Executors提供四种线程池
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 

newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 

newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 

newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

### new Thread的弊端
+ 每次new Thread新建对象性能差。
+ 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
+ 缺乏更多功能，如定时执行、定期执行、线程中断。
相比new Thread，Java提供的四种线程池的好处在于：
+ 重用存在的线程，减少对象创建、消亡的开销，性能佳。
+ 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
+ 提供定时执行、定期执行、单线程、并发数控制等功能。


Q:同步/异步和阻塞/非阻塞的区别
===
### 同步、异步 
+ 概念：消息的通知机制
+ 解释：涉及到IO通知机制；所谓同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；所谓异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果。
  
### 阻塞、非阻塞
+ 概念：程序等待调用结果时的状态
+ 解释：涉及到CPU线程调度；所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。