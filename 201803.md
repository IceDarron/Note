Q:分治
===

### 分治基本思想
> 分而治之。把一个复杂的问题分成两个或更多的相同或相似的子问题，
再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，
原问题的解即子问题的解的合并。
实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。

### 分治策略
> 对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，
否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，
递归地解这些子问题，然后将各子问题的解合并得到原问题的解。

### 分治法适用的情况
+ 该问题的规模缩小到一定的程度就可以容易地解决。
+ 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。
+ 利用该问题分解出的子问题的解可以合并为该问题的解。
+ 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

> 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加。
第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用。
第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，
如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。
第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，
重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

### 分治法的基本步骤
+ 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
+ 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
+ 合并：将各个子问题的解合并为原问题的解。

### 分治法的复杂性分析
> 一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。
再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。
用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：

T（n）= k T(n/m)+f(n)

通过迭代法求得方程的解：

> 递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。
通常假定T(n)是单调上升的，从而当 mi≤n<mi+1时，T(mi)≤T(n)<T(mi+1)。

### 经典问题
+ 二分搜索
+ 大整数乘法
+ Strassen矩阵乘法
+ 棋盘覆盖
+ 合并排序
+ 快速排序
+ 线性时间选择
+ 最接近点对问题
+ 循环赛日程表
+ 汉诺塔


Q:动态规划算法
===

### 基本思想
 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。
 一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
 有点类似于数学归纳法。
 
### 适用的情况
+ 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
+ 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
+ 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。
（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
   
### 基本步骤
+ 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
+ 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
+ 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
+ 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

>  动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。
一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。

经典实现：

```text
 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}
```

### 经典问题
登1-n台阶问题
   

Q:贪心算法
===
### 基本概念
所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。
也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。

### 基本思路
+ 建立数学模型来描述问题。
+ 把求解的问题分成若干个子问题。
+ 对每一子问题求解，得到子问题的局部最优解。
+ 把子问题的解局部最优解合成原来解问题的一个解。
    
### 适用场景
实际上，贪心算法适用的情况很少。
贪心策略适用的前提是：局部最优策略能导致产生全局最优解。

### 基本步骤
从问题的某一初始解出发；
while （能朝给定总目标前进一步）
{ 
      利用可行的决策，求出可行解的一个解元素；
}
由所有解元素组合成问题的一个可行解；

### 经典问题

[背包问题]

有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。
要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。
物品 A B C D E F G
重量 35 30 60 50 40 10 25
价值 10 40 30 50 35 40 30
分析：
目标函数： ∑pi最大
约束条件是装入的物品总重量不超过背包容量：∑wi<=M( M=150)
（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？
（2）每次挑选所占重量最小的物品装入是否能得到最优解？
（3）每次选取单位重量价值最大的物品，成为解本题的策略。
值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。
贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。
可惜的是，它需要证明后才能真正运用到题目的算法中。
一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。
对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：
（1）贪心策略：选取价值最大者。反例：
W=30
物品：A B C
重量：28 12 12
价值：30 20 20
根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。
（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。
（3）贪心策略：选取单位重量价值最大的物品。反例：
W=30
物品：A B C
重量：28 20 10
价值：28 20 10
根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。


Q:回溯法
===
### 基本概念
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。
但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，
而满足回溯条件的某个状态的点称为“回溯点”。
许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

### 基本思想
在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。
当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。
（其实回溯法就是对隐式图的深度优先搜索算法）。
若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。
而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

### 基本步骤
针对所给问题，确定问题的解空间：
+ 先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。
+ 确定结点的扩展搜索规则
+ 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

### 经典问题
数独问题


Q:分支限界法
===
### 基本概念
类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。
但在一般情况下，分支限界法与回溯法的求解目标不同。
回溯法的求解目标是找出T中满足约束条件的所有解，
而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

### 搜索策略
在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。
为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，
从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。

### 经典问题
A星算法



Q:Paxos算法原理与推导
===
https://www.cnblogs.com/linbingdong/p/6253479.html


Q:一致性哈希算法原理
===
https://www.cnblogs.com/lpfuture/p/5796398.html


Q:SOA和微服务架构的区别
===
https://www.zhihu.com/question/37808426


Q:classloader如何造成内存泄漏
===
http://www.tinygroup.org/blog/detail/5e78ace84a594e97905c2b2c44ee97f6