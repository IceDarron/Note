Q:Oracle高级查询之OVER (PARTITION BY ..), 解决查询分组后某列最大的那条数据。
===
### 基本方式：
``` SQL
SELECT E.ID,E.NAME, E.AGE, E.INFO 
FROM EMPLOYEE E, 
(SELECT E.ID, MAX( E.AGE) E.AGE FROM EMPLOYEE E GROUP BY E.ID) T 
WHERE E.ID= T.ID 
AND E.AGE= T.AGE;
```
### 利用OVER (PARTITION BY ..)：
``` SQL
SELECT T.ID, T.NAME, T.AGE, T.INFO 
FROM (SELECT E.*, ROW_NUMBER() OVER(PARTITION BY E.ID ORDER BY E.AGE DESC) AS NUM 
FROM EMPLOYEE E 
) T 
WHERE T.NUM = 1
```

##### 详细资料：http://www.cnblogs.com/shined/archive/2013/01/16/2862809.html

Q:解决mysql排序字段的数据为中文时不能正常显示结果的问题
===
### 问题：
> order by 排序时 对应的字段为中文 则需要转换编码。

### 解决方法：
``` SQL
convert(B.C_GZDW using gbk) ASC
```
### 结果：
> 中文会按照汉字汉语拼音首字母在26字母表的顺序排序，相同则推向下一个汉字，完全相同，应该是稳定排序吧，我猜测。

Q:解决oracle数据库wm_concat()字符串拼接过长问题
===
> wm_concat()拼接字符串的结果只能达到4000，超过的时候需要重写一个方法，不过实际运行的时候会特别慢，这种函数只能在平时对数据进行单次查询的时候用到，在实际业务中感觉性能太差了，之前读取的数据最后分类为159组，最大组数据为3000不到个元素，总共查询时间大概有480s。

> 直接上sql了，事实证明是好用的，如果你的navicat不好用的话，试用下sqldeveloper试下。
``` SQL
create or replace TYPE zh_concat_im  

AUTHID CURRENT_USER AS OBJECT
(
  CURR_STR clob,
  STATIC FUNCTION ODCIAGGREGATEINITIALIZE(SCTX IN OUT zh_concat_im) RETURN NUMBER,
  MEMBER FUNCTION ODCIAGGREGATEITERATE(SELF IN OUT zh_concat_im,  
  P1 IN CLOB) RETURN NUMBER,
  MEMBER FUNCTION ODCIAGGREGATETERMINATE(SELF IN zh_concat_im,
  RETURNVALUE OUT CLOB,
  FLAGS IN NUMBER)
  RETURN NUMBER,
  MEMBER FUNCTION ODCIAGGREGATEMERGE(SELF IN OUT zh_concat_im,  
  SCTX2 IN zh_concat_im) RETURN NUMBER
);

create or replace TYPE BODY zh_concat_im
IS
  STATIC FUNCTION ODCIAGGREGATEINITIALIZE(SCTX IN OUT zh_concat_im)
  RETURN NUMBER  
  IS
  BEGIN
  SCTX := zh_concat_im(NULL) ;
  RETURN ODCICONST.SUCCESS;
  END;
  MEMBER FUNCTION ODCIAGGREGATEITERATE(SELF IN OUT zh_concat_im,
  P1 IN CLOB)  
  RETURN NUMBER  
  IS
  BEGIN
  IF(CURR_STR IS NOT NULL) THEN  
  CURR_STR := CURR_STR || ',' || P1;
  ELSE
  CURR_STR := P1;
  END IF;
  RETURN ODCICONST.SUCCESS;
  END;
  MEMBER FUNCTION ODCIAGGREGATETERMINATE(SELF IN zh_concat_im,
  RETURNVALUE OUT CLOB,
  FLAGS IN NUMBER)
  RETURN NUMBER  
  IS
  BEGIN
  RETURNVALUE := CURR_STR ;
  RETURN ODCICONST.SUCCESS;
  END;
  MEMBER FUNCTION ODCIAGGREGATEMERGE(SELF IN OUT zh_concat_im,  
  SCTX2 IN zh_concat_im)  
  RETURN NUMBER  
  IS
  BEGIN
  IF(SCTX2.CURR_STR IS NOT NULL) THEN  
  SELF.CURR_STR := SELF.CURR_STR || ',' || SCTX2.CURR_STR ;
  END IF;
  RETURN ODCICONST.SUCCESS;
  END;
END;

create or replace FUNCTION zh_concat(P1 CLOB)  
RETURN CLOB AGGREGATE USING zh_concat_im ;

SELECT A.C_ET_ID,B.C_N,COUNT(DISTINCT A.C_EN) AS NUM,zh_concat(DISTINCT A.C_EN)
FROM DU.T_S_E A
LEFT JOIN DU.T_ET B ON A.C_ET_ID = B.C_ID
GROUP BY A.C_ET_ID,B.C_N
ORDER BY NUM DESC;
``` 

Q:oracle数据库sys及system密码修改，数据库数据导出导入（dmp）
===
解锁账户：alter user 账户 account unlock
登录sys用户：sqlplus / as sysdba
修改sys用户：alter user sys identify by password
修改system用户：alter user system identified by 

数据导出：
 1 将数据库TEST完全导出,用户名system 密码manager 导出到D:\daochu.dmp中
   exp system/manager@TEST file=d:\daochu.dmp full=y
 2 将数据库中system用户与sys用户的表导出
   exp system/manager@TEST file=d:\daochu.dmp owner=(system,sys)
 3 将数据库中的表table1 、table2导出
   exp system/manager@TEST file=d:\daochu.dmp tables=(table1,table2) 
 4 将数据库中的表table1中的字段filed1以"00"打头的数据导出
   exp system/manager@TEST file=d:\daochu.dmp tables=(table1) query=\" where filed1 like '00%'\"
  
上面是常用的导出，对于压缩我不太在意，用winzip把dmp文件可以很好的压缩。
不过在上面命令后面 加上 compress=y  就可以了 

数据的导入：
 1 将D:\daochu.dmp 中的数据导入 TEST数据库中。
   imp system/manager@TEST  file=d:\daochu.dmp
   上面可能有点问题，因为有的表已经存在，然后它就报错，对该表就不进行导入。
   在后面加上 ignore=y 就可以了。
 2 将d:\daochu.dmp中的表table1 导入
 imp system/manager@TEST  file=d:\daochu.dmp  tables=(table1) 

注意事项：导出dmp数据时需要有导出表的权限的用户，否则不能导出。
